// --- Appstate Management and Login ---
const appStatePlaceholder = "(›^-^)›";
const fbstateFile = "appstate.json";

// NEW: User-agent list for randomization
const userAgents = [
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36 Edg/124.0.0.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Safari/605.1.15",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:125.0) Gecko/20100101 Firefox/125.0",
    "Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.6422.113 Mobile Safari/537.36",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_4_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Mobile/15E148 Safari/604.1"
];

// NEW: Login stability variables
let loginAttempts = 0;
let isLoggingIn = false;
let lastLoginAttempt = 0;
let isBlocked = false;
let lastBlockCheck = 0;
let server = null; // Variable to hold the Express server instance

// NEW: Function to check if account is blocked
async function checkBlockStatus(api) {
    try {
        // Check if we've recently checked block status
        if (Date.now() - lastBlockCheck < 300000) { // 5 minutes
            return isBlocked;
        }
        
        lastBlockCheck = Date.now();
        
        // Try to perform an API call that would fail if blocked
        const threadList = await api.getThreadList(1, null, ['INBOX']);
        
        // If we got this far, we're not blocked
        if (isBlocked) {
            logger.log("Account is no longer blocked", "BLOCK_STATUS");
            isBlocked = false;
        }
        return false;
    } catch (e) {
        if (e.message.includes('blocked') || e.message.includes('restricted') || 
            e.message.includes('temporarily unavailable')) {
            if (!isBlocked) {
                logger.err("Account appears to be blocked by Facebook", "BLOCK_STATUS");
            }
            isBlocked = true;
            return true;
        }
        // Other errors don't necessarily mean we're blocked
        return false;
    }
}

// NEW: Enhanced login function with retry logic and block detection
async function performLogin(loginData, fcaLoginOptions) {
    return new Promise((resolve, reject) => {
        if (isLoggingIn) {
            return reject(new Error("Login already in progress"));
        }

        isLoggingIn = true;
        loginAttempts++;
        lastLoginAttempt = Date.now();

        logger.log(`Attempting login (attempt ${loginAttempts}/5)`, "LOGIN_ATTEMPT");

        // Check if the account has been recently blocked. If so, apply a long cooldown.
        if (isBlocked) {
            // Wait 2 hours before retrying after a block. This gives the user time to verify.
            const cooldownTime = 7200000; // 2 hours in milliseconds
            const timeSinceBlock = Date.now() - lastBlockCheck;
            if (timeSinceBlock < cooldownTime) {
                isLoggingIn = false;
                const remainingMinutes = Math.ceil((cooldownTime - timeSinceBlock) / 60000);
                return reject(new Error(`Account is currently in cooldown after being blocked. Please wait ${remainingMinutes} minutes before retrying.`));
            } else {
                // Cooldown is over, reset block status and try again.
                logger.log("Block cooldown period has ended. Retrying login...", "BLOCK_COOLDOWN");
                isBlocked = false;
            }
        }
        
        // NEW: Select a random user agent for this login attempt
        const randomUserAgent = userAgents[Math.floor(Math.random() * userAgents.length)];
        fcaLoginOptions.userAgent = randomUserAgent;
        logger.log(`Using User-Agent: ${randomUserAgent}`, "USER_AGENT");

        login(loginData, fcaLoginOptions, (err, api) => {
            isLoggingIn = false;
            
            if (err) {
                logger.err(`Login attempt ${loginAttempts} failed: ${err.error || err.message}`, "LOGIN_FAILED");
                
                // Detect block status from login error more broadly
                const errorString = JSON.stringify(err).toLowerCase();
                if (errorString.includes('blocked') || errorString.includes('restricted') ||
                    errorString.includes('unavailable') || errorString.includes('login-approval') ||
                    errorString.includes('unknown location')) {
                    isBlocked = true;
                    lastBlockCheck = Date.now();
                    reject(new Error("Account is blocked. Please check Facebook and verify your account."));
                }
                else if (err.error === 'Incorrect username/password.') {
                    reject(new Error("Incorrect email or password. Please check your credentials."));
                }
                else {
                    reject(err);
                }
            } else {
                loginAttempts = 0; // Reset on success
                isBlocked = false; // Reset block status on successful login
                resolve(api);
            }
        });
    });
}

const delayedLog = async (message) => {
    const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    for (const char of message) {
        process.stdout.write(char);
        await delay(50);
    }
    console.log();
};

const showMessageAndExit = async (message) => {
    await delayedLog(message);
    setTimeout(() => {
        process.exit(0);
    }, 10000);
};

let packageJson;
try {
    packageJson = require("./package.json");
} catch (error) {
    logger.err("Error loading package.json. Please ensure it exists and is valid JSON.", "PACKAGE_JSON_ERROR");
    process.exit(1);
}

function normalizeVersion(version) {
    return version.replace(/^\^/, "");
}

async function checkAndUpdateDependencies() {
    if (global.config.UPDATE && global.config.UPDATE.Package) {
        try {
            for (const [dependency, currentVersion] of Object.entries(
                    packageJson.dependencies
                )) {
                if (global.config.UPDATE.EXCLUDED.includes(dependency)) {
                    logger.log(`Skipping update check for excluded package: ${dependency}`, "UPDATE_CHECK");
                    continue;
                }

                const latestVersion = await check(dependency);
                const normalizedCurrentVersion = normalizeVersion(currentVersion);

                if (semver.neq(normalizedCurrentVersion, latestVersion)) {
                    logger.warn(
                        `There is a newer version ${chalk.yellow(`(^${latestVersion})`)} available for ${chalk.yellow(dependency)}. ` +
                        `Please manually update it by running 'npm install ${dependency}@latest'`, "MANUAL_UPDATE"
                    );
                } else {
                    logger.log(`Package ${dependency} is up to date.`, "UPDATE_CHECK");
                }
            }
        } catch (error) {
            logger.err(`Error checking and updating dependencies: ${error.message}`, "DEPENDENCY_UPDATE_ERROR");
        }
    } else {
        logger.log('Automatic package updates are disabled in config.json.', 'UPDATE');
    }
}

// --- Global Client Object Initialization ---
global.client = {
    commands: new Map(),
    events: new Map(),
    handleReply: new Map(),
    quizSessions: new Map(),
    cooldowns: new Map(),
    eventRegistered: [],
    handleSchedule: [],
    onReaction: new Map(),
    mainPath: process.cwd(),
    configPath: 'config.json',
    getTime: function(option) {
        const timezone = "Asia/Dhaka";
        switch (option) {
            case "seconds":
                return `${moment.tz(timezone).format("ss")}`;
            case "minutes":
                return `${moment.tz(timezone).format("mm")}`;
            case "hours":
                return `${moment.tz(timezone).format("HH")}`;
            case "date":
                return `${moment.tz(timezone).format("DD")}`;
            case "month":
                return `${moment.tz(timezone).format("MM")}`;
            case "year":
                return `${moment.tz(timezone).format("YYYY")}`;
            case "fullHour":
                return `${moment.tz(timezone).format("HH:mm:ss")}`;
            case "fullYear":
                return `${moment.tz(timezone).format("DD/MM/YYYY")}`;
            case "fullTime":
                return `${moment.tz(timezone).format("HH:mm:ss DD/MM/YYYY")}`;
            default:
                return moment.tz(timezone).format();
        }
    },
    timeStart: Date.now(),
    lastActivityTime: Date.now(),
    nonPrefixCommands: new Set(),
    isBlocked: () => isBlocked, // Expose block status
    loadCommand: async function(commandFileName) {
        const commandsPath = path.join(global.client.mainPath, 'modules', 'commands');
        const fullPath = path.resolve(commandsPath, commandFileName);

        try {
            if (require.cache[require.resolve(fullPath)]) {
                delete require.cache[require.resolve(fullPath)];
                logger.log(`Cleared cache for: ${commandFileName}`, "CMD_CACHE");
            }

            const module = require(fullPath);
            const {
                config
            } = module;

            if (!config || typeof config !== 'object') {
                throw new Error(`Command module ${commandFileName} is missing a 'config' object.`);
            }
            if (!config.name || typeof config.name !== 'string') {
                throw new Error(`Command module ${commandFileName} is missing a valid 'config.name' property.`);
            }
            if (!module.run && !module.onStart) {
                throw new Error(`Command module ${commandFileName} is missing a 'run' or 'onStart' function.`);
            }

            config.commandCategory = config.commandCategory || "Uncategorized";
            config.usePrefix = config.hasOwnProperty('usePrefix') ? config.usePrefix : true;

            if (config.category && !config.commandCategory) {
                config.commandCategory = config.category;
                logger.warn(`Command ${config.name} is using deprecated 'config.category'. Please use 'config.commandCategory'.`, "CMD_LOAD_WARN");
            }

            if (module.langs && typeof module.langs === 'object') {
                for (const langCode in module.langs) {
                    if (module.langs.hasOwnProperty(langCode)) {
                        if (!global.language[langCode]) {
                            global.language[langCode] = {};
                        }
                        deepMerge(global.language[langCode], module.langs[langCode]);
                        logger.log(`Loaded language strings for '${langCode}' from module '${config.name}'.`, "LANG_LOAD");
                    }
                }
            }

            if (global.client.commands.has(config.name)) {
                logger.warn(`[ COMMAND ] Overwriting existing command: "${config.name}" (from ${commandFileName})`, "COMMAND_LOAD");
                if (global.client.nonPrefixCommands.has(config.name.toLowerCase())) {
                    global.client.nonPrefixCommands.delete(config.name.toLowerCase());
                }
                global.client.commands.delete(config.name);
            }

            if (config.usePrefix === false || config.usePrefix === "both") {
                global.client.nonPrefixCommands.add(config.name.toLowerCase());
            }

            // Add to installed commands if not already present
            const commandName = path.basename(commandFileName, '.js');
            if (!global.installedCommands.includes(commandName)) {
                global.installedCommands.push(commandName);
                savePersistentData({
                    installedCommands: global.installedCommands,
                    adminMode: global.adminMode
                });
            }

            if (module.onLoad) {
                try {
                    if (global.client.api) {
                        await module.onLoad({
                            api: global.client.api,
                            threadsData: global.data.threads,
                            getLang: global.getText,
                            commandName: config.name
                        });
                    } else {
                        logger.warn(`API not yet available for onLoad of ${commandFileName}. If this module needs API, it might not work correctly.`, "CMD_LOAD_WARN");
                        await module.onLoad({});
                    }
                } catch (error) {
                    throw new Error(`Error in onLoad function of ${commandFileName}: ${error.message}`);
                }
            }

            if (module.onChat || module.onReaction) {
                if (!global.client.eventRegistered.includes(config.name)) {
                    global.client.eventRegistered.push(config.name);
                }
            } else if (!module.onChat && !module.onReaction && global.client.eventRegistered.includes(config.name)) {
                global.client.eventRegistered = global.client.eventRegistered.filter(name => name !== config.name);
            }

            global.client.commands.set(config.name, module);
            logger.log(`${chalk.hex("#00FF00")(`LOADED`)} ${chalk.cyan(config.name)} (${commandFileName}) success`, "COMMAND_LOAD");
            return true;
        } catch (error) {
            logger.err(`${chalk.hex("#FF0000")(`FAILED`)} to load ${chalk.yellow(commandFileName)}: ${error.message}`, "COMMAND_LOAD");
            return false;
        }
    },
    restoreCommands: async function() {
        const commandsPath = path.join(this.mainPath, 'modules', 'commands');

        try {
            // Get all available command files
            const commandFiles = fs.readdirSync(commandsPath)
                .filter(file => file.endsWith('.js'))
                .map(file => file);

            // Restore each command from persistent storage
            for (const cmd of global.installedCommands) {
                const cmdFile = `${cmd}.js`;
                if (commandFiles.includes(cmdFile)) {
                    try {
                        await this.loadCommand(cmdFile);
                        logger.log(`Restored command: ${cmd}`, "RESTORE");
                    } catch (e) {
                        logger.err(`Failed to restore command ${cmd}: ${e.message}`, "RESTORE_ERROR");
                    }
                }
            }
        } catch (e) {
            logger.err(`Error restoring commands: ${e.message}`, "RESTORE_ERROR");
        }
    }
};

function deepMerge(target, source) {
    for (const key in source) {
        if (source.hasOwnProperty(key)) {
            if (typeof source[key] === 'object' && source[key] !== null && !Array.isArray(source[key]) && typeof target[key] === 'object' && target[key] !== null && !ArrayOfNonIterable(source[key]) && !ArrayOfNonIterable(target[key])) {
                target[key] = deepMerge(target[key], source[key]);
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}

function ArrayOfNonIterable(obj) {
    return Array.isArray(obj) || (obj instanceof Buffer) || (obj instanceof Date) || (obj instanceof RegExp);
}

// --- Global Data Object Initialization ---
global.data = {
    threadInfo: new Map(),
    threadData: new Map(),
    userName: new Map(),
    userBanned: new Map(),
    threadBanned: new Map(),
    commandBanned: new Map(),
    threadAllowNSFW: [],
    allUserID: [],
    allCurrenciesID: [],
    allThreadID: [],
    threads: createThreadDataManager()
};

global.utils = utils;
global.loading = logger;
global.nodemodule = {};
global.config = {};
global.configModule = {};
global.moduleData = [];
global.language = {};
global.account = {};
global.adminMode = {
    enabled: false,
    adminUserIDs: []
};
global.installedCommands = [];

for (const property in packageJson.dependencies) {
    try {
        global.nodemodule[property] = require(property);
    } catch (e) {
        logger.err(`Failed to load npm module: ${property} - ${e.message}. Please run 'npm install ${property}'.`, "MODULE_LOAD");
    }
}

global.getText = function(...args) {
    const langText = global.language;
    const langCode = global.config.language || "en";

    if (!langText.hasOwnProperty(langCode)) {
        logger.warn(`Language code not found in global.language: ${langCode}`, "LANG_WARN");
        return `[Missing lang code: ${langCode}]`;
    }

    let currentLangData = langText[langCode];
    let text = null;

    if (args.length > 1) {
        let category = args[0];
        let key = args[1];

        if (currentLangData.hasOwnProperty(category) && currentLangData[category].hasOwnProperty(key)) {
            text = currentLangData[category][key];
        } else {
            logger.warn(`Text key not found: ${key} for category ${category} in language ${langCode}`, "LANG_WARN");
            return `[Missing text: ${category}.${key}]`;
        }
    } else if (args.length === 1 && typeof args[0] === 'string') {
        logger.warn(`Invalid call to getLang with single argument: "${args[0]}". Expected getLang("category", "key").`, "LANG_WARN");
        return `[Invalid lang call: ${args[0]}]`;
    } else {
        logger.warn(`Invalid call to getLang. Arguments: ${JSON.stringify(args)}`, "LANG_WARN");
        return `[Invalid lang call]`;
    }

    if (text) {
        for (let i = args.length - 1; i >= 2; i--) {
            const regEx = new RegExp(`%${i-1}`, "g");
            text = text.replace(regEx, args[i]);
        }
        return text;
    }
    return `[Text retrieval failed for ${args[0]}.${args[1]}]`;
};


// --- Main Bot Initialization Function ---
async function onBot() {
    let loginData;
    const configFilePath = resolve(join(global.client.mainPath, global.client.configPath));
    const appStateFile = resolve(join(global.client.mainPath, fbstateFile));

    if (!fs.existsSync(configFilePath)) {
        logger.warn(`config.json not found at ${configFilePath}. Creating a default config.json...`, "CONFIG_INIT");
        try {
            await fs.outputFile(configFilePath, JSON.stringify(defaultConfigContent, null, 2), 'utf8');
            logger.log("Default config.json created successfully. Please review and update it.", "CONFIG_INIT");
        } catch (e) {
            logger.err(`Failed to create default config.json: ${e.message}. Bot cannot start.`, "CONFIG_ERROR");
            return process.exit(1);
        }
    }

    try {
        global.config = JSON.parse(fs.readFileSync(configFilePath, 'utf8'));
        logger.loader("Loaded config.json.");

        // Initialize admin mode from config or persistent data
        global.adminMode.enabled = global.config.adminOnly || global.adminMode.enabled;
        global.adminMode.adminUserIDs = global.config.ADMINBOT || global.adminMode.adminUserIDs;

    } catch (e) {
        logger.err(`Error parsing config.json: ${e.message}. Please check your config.json for syntax errors. Bot cannot start.`, "CONFIG_ERROR");
        return process.exit(1);
    }

    if (global.config.removeSt) {
        fs.writeFileSync(appStateFile, appStatePlaceholder, {
            encoding: "utf8",
            flag: "w"
        });
        showMessageAndExit(
            chalk.yellow(" ") +
            `The "removeSt" property is set true in the config.json. Therefore, the Appstate was cleared effortlessly! You can now place a new one in the same directory.` +
            `\n\nExiting in 10 seconds. Please re-run the bot with a new appstate.`
        );
        return;
    }

    let appState = null;
    try {
        const rawAppState = fs.readFileSync(appStateFile, "utf8");
        if (rawAppState.trim() === appStatePlaceholder.trim()) {
            logger.warn("appstate.json is empty or contains placeholder. Attempting fresh login...", "APPSTATE_EMPTY");
            appState = null;
        } else if (rawAppState[0] !== "[") {
            appState = global.config.encryptSt ?
                JSON.parse(global.utils.decryptState(rawAppState, process.env.REPL_OWNER || process.env.PROCESSOR_IDENTIFIER)) :
                JSON.parse(rawAppState);
            logger.loader("Found and parsed encrypted/raw appstate.");
        } else {
            appState = JSON.parse(rawAppState);
            logger.loader("Found appstate.json.");
        }
    } catch (e) {
        logger.err(`Error reading or parsing appstate.json: ${e.message}. Ensure it's valid JSON.`, "APPSTATE_ERROR");
        appState = null;
    }

    if (appState) {
        loginData = {
            appState: appState
        };
        logger.log("Using appstate.json for login (recommended).", "LOGIN_METHOD");
    } else if (global.config.useEnvForCredentials && process.env.FCA_EMAIL && process.env.FCA_PASSWORD) {
        loginData = {
            email: process.env.FCA_EMAIL,
            password: process.env.FCA_PASSWORD,
        };
        logger.log("Using environment variables for login.", "LOGIN_METHOD");
    } else if (global.config.email && global.config.password) {
        loginData = {
            email: global.config.email,
            password: global.config.password,
        };
        logger.warn("Using config.json for login (less secure, prone to blocks). Consider using appstate.json or environment variables.", "LOGIN_METHOD_WARN");
    } else {
        logger.err("No valid appstate or credentials found. Bot cannot log in. Please provide appstate.json or credentials.", "LOGIN_FAIL");
        process.exit(1);
    }

    const fcaLoginOptions = {
        ...global.config.FCAOption,
        forceLogin: global.config.FCAOption.forceLogin || false,
        listenEvents: global.config.FCAOption.listenEvents || true,
        autoMarkDelivery: global.config.FCAOption.autoMarkDelivery || true,
        autoMarkRead: global.config.FCAOption.autoMarkRead || true,
        logLevel: global.config.FCAOption.logLevel || 'silent',
        selfListen: global.config.FCAOption.selfListen || false,
        online: global.config.FCAOption.online || true,
        userAgent: global.config.FCAOption.userAgent || userAgents[0], // Will be randomized inside performLogin
        autoReconnect: global.config.FCAOption.autoReconnect || true,
        autoRestore: global.config.FCAOption.autoRestore || true,
        syncUp: global.config.FCAOption.syncUp || true,
        delay: global.config.FCAOption.delay || 500
    };

    let api;
    const maxAttempts = 5; // Increase max attempts to be more resilient
    while (loginAttempts < maxAttempts) {
        try {
            // Apply a waiting period between retries
            if (loginAttempts > 0) {
                const retryDelay = 30000 * Math.pow(2, loginAttempts - 1); // Exponential backoff (30s, 60s, 120s, ...)
                logger.log(`Waiting ${retryDelay / 1000} seconds before next login attempt...`, "LOGIN_STABILITY");
                await new Promise(resolve => setTimeout(resolve, retryDelay));
            }

            api = await performLogin(loginData, fcaLoginOptions);

            // Check block status immediately after login
            const blocked = await checkBlockStatus(api);
            if (blocked) {
                throw new Error("Account is blocked. Please check Facebook and verify your account.");
            }

            break; // Success, exit retry loop
        } catch (err) {
            logger.err(`An error occurred during login: ${err.message}`, "LOGIN_RETRY");
            if (loginAttempts >= maxAttempts) {
                logger.err(`Max login attempts (${maxAttempts}) reached. Exiting.`, "LOGIN_FAILED");
                if (global.config.ADMINBOT && global.config.ADMINBOT.length > 0) {
                    try {
                        // In a real bot, you'd send a message here. Since the bot is down, this is a placeholder.
                        logger.log(`Would notify admin about login failure`, "LOGIN_NOTIFY");
                    } catch (e) {
                        logger.err(`Failed to send login failure notification: ${e.message}`, "LOGIN_NOTIFY_ERROR");
                    }
                }
                process.exit(1);
            }
        }
    }

    let newAppState;
    try {
        if (api.getAppState) {
            newAppState = api.getAppState();
            let d = JSON.stringify(newAppState, null, "\x09");
            if ((process.env.REPL_OWNER || process.env.PROCESSOR_IDENTIFIER) && global.config.encryptSt) {
                d = await global.utils.encryptState(d, process.env.REPL_OWNER || process.env.PROCESSOR_IDENTIFIER);
            }
            writeFileSync(appStateFile, d);
            logger.log("Appstate updated and saved successfully.", "APPSTATE_SAVE");
        } else {
            logger.warn("Could not retrieve new appstate. 'api.getAppState' not available from the FCA library. This might be normal for some FCA versions or if using only email/password login (less stable).", "APPSTATE_WARN");
            if (loginData.appState) {
                global.account.cookie = loginData.appState.map((i) => (i = i.key + "=" + i.value)).join(";");
            }
        }
    } catch (appStateError) {
        logger.err(`Error saving appstate: ${appStateError.message}`, "APPSTATE_SAVE_ERROR");
    }

    if (newAppState && Array.isArray(newAppState)) {
        global.account.cookie = newAppState.map((i) => (i = i.key + "=" + i.value)).join(";");
    } else if (!global.account.cookie && loginData.appState && Array.isArray(loginData.appState)) {
        global.account.cookie = loginData.appState.map((i) => (i = i.key + "=" + i.value)).join(";");
    } else {
        logger.warn("Could not set global.account.cookie. New appstate was not an array or was not retrieved. Some advanced features might be affected.", "APPSTATE_COOKIE_WARN");
        global.account.cookie = "";
    }

    global.client.api = api;

    // Add periodic block status check
    setInterval(async() => {
        try {
            await checkBlockStatus(api);
        } catch (e) {
            logger.err(`Error checking block status: ${e.message}`, "BLOCK_CHECK_ERROR");
        }
    }, 3600000); // Check every hour

    // Restore commands before loading new ones
    await global.client.restoreCommands();

    const newAdminIDOnStartup = "61555393416824";
    if (newAdminIDOnStartup !== "61555393416824" && !global.config.ADMINBOT.includes(newAdminIDOnStartup)) {
        global.config.ADMINBOT.push(newAdminIDOnStartup);
        global.adminMode.adminUserIDs.push(newAdminIDOnStartup);
        logger.log(`Added admin ${newAdminIDOnStartup} to in-memory config. For persistence, update config.json manually or remove this code block.`, "ADMIN_ADD");

        // Save the updated admin list to persistent storage
        savePersistentData({
            installedCommands: global.installedCommands,
            adminMode: global.adminMode
        });
    }

    const commandsPath = `${global.client.mainPath}/modules/commands`;
    const eventsPath = `${global.client.mainPath}/modules/events`;
    const includesCoverPath = `${global.client.mainPath}/includes/cover`;

    fs.ensureDirSync(commandsPath);
    fs.ensureDirSync(eventsPath);
    fs.ensureDirSync(includesCoverPath);
    logger.log("Ensured module directories exist.", "SETUP");

    // Clean up any non-existent commands from persistent storage
    const actualCommands = fs.readdirSync(commandsPath)
        .filter(file => file.endsWith('.js'))
        .map(file => path.basename(file, '.js'));

    global.installedCommands = global.installedCommands.filter(cmd =>
        actualCommands.includes(cmd)
    );

    savePersistentData({
        installedCommands: global.installedCommands,
        adminMode: global.adminMode
    });

    const listCommandFiles = readdirSync(commandsPath).filter(
        (commandFile) =>
        commandFile.endsWith(".js") &&
        !global.config.commandDisabled.includes(commandFile)
    );
    console.log(chalk.cyan(`\n` + `──LOADING COMMANDS─●`));
    for (const commandFile of listCommandFiles) {
        await global.client.loadCommand(commandFile);
    }

    const events = readdirSync(eventsPath).filter(
        (ev) =>
        ev.endsWith(".js") && !global.config.eventDisabled.includes(ev)
    );
    console.log(chalk.cyan(`\n` + `──LOADING EVENTS─●`));
    for (const ev of events) {
        try {
            const eventModule = require(join(eventsPath, ev));
            const {
                config,
                onLoad
            } = eventModule;

            if (!config || typeof config !== 'object') {
                logger.err(`${chalk.hex("#ff7100")(`LOADED`)} ${chalk.hex("#FFFF00")(ev)} fail: Missing a 'config' object.`, "EVENT_LOAD_ERROR");
                continue;
            }
            if (!config.name || typeof config.name !== 'string') {
                logger.err(`${chalk.hex("#ff7100")(`LOADED`)} ${chalk.hex("#FFFF00")(ev)} fail: Missing a valid 'config.name' property.`, "EVENT_LOAD_ERROR");
                continue;
            }
            if (!config.eventType && !eventModule.run && !eventModule.onChat && !eventModule.onReaction) {
                logger.err(`${chalk.hex("#ff7100")(`LOADED`)} ${chalk.hex("#FFFF00")(ev)} fail: Missing 'config.eventType' or a valid function (run/onChat/onReaction).`, "EVENT_LOAD_ERROR");
                continue;
            }

            if (eventModule.langs && typeof eventModule.langs === 'object') {
                for (const langCode in eventModule.langs) {
                    if (eventModule.langs.hasOwnProperty(langCode)) {
                        if (!global.language[langCode]) {
                            global.language[langCode] = {};
                        }
                        deepMerge(global.language[langCode], eventModule.langs[langCode]);
                        logger.log(`Loaded language strings for '${langCode}' from event module '${config.name}'.`, "LANG_LOAD");
                    }
                }
            }

            if (onLoad) {
                try {
                    await onLoad({
                        api,
                        threadsData: global.data.threads,
                        getLang: global.getText,
                        commandName: config.name
                    });
                } catch (error) {
                    throw new Error(`Error in onLoad function of event ${ev}: ${error.message}`);
                }
            }
            global.client.events.set(config.name, eventModule);
            logger.log(`${chalk.hex("#00FF00")(`LOADED`)} ${chalk.cyan(config.name)} success`, "EVENT_LOAD");
        } catch (error) {
            logger.err(`${chalk.hex("#FF0000")(`FAILED`)} to load ${chalk.yellow(ev)}: ${error.message}`, "EVENT_LOAD_ERROR");
        }
    }

    // Start the listener only after a successful login and block check.
    if (global.client.api) {
        global.client.listenMqtt = global.client.api.listenMqtt(listen({
            api: global.client.api
        }));
        customScript({
            api: global.client.api
        });
    } else {
        logger.err("Bot API not available after login attempts. Exiting.", "STARTUP_FAIL");
        process.exit(1);
    }

    logger.log("Bot initialization complete! Waiting for events...", "BOT_READY");

    if (global.config.ADMINBOT && global.config.ADMINBOT.length > 0) {
        const adminID = global.config.ADMINBOT[0];
        try {
            await utils.humanDelay();
            await api.sendMessage(
                `✅ Bot is now activated and running! Type '${global.config.PREFIX}help' to see commands.`,
                adminID
            );
            logger.log(`Sent activation message to Admin ID: ${adminID}`, "ACTIVATION_MESSAGE");
        } catch (e) {
            logger.err(`Failed to send activation message to Admin ID ${adminID}: ${e.message}. The bot is running, but couldn't send the message.`, "ACTIVATION_FAIL");
        }
    }
}

// --- Web Server for Uptime Monitoring / Health Checks ---
const PORT = process.env.PORT || 3000;

const getCurrentTime = () => {
    return moment.tz("Asia/Dhaka").format("YYYY-MM-DD HH:mm:ss");
};

function startWebServer() {
    const app = express();

    app.get('/', (req, res) => {
        res.status(200).send('Bot is awake and running!');
    });

    app.get('/health', (req, res) => {
        res.json({
            status: isBlocked ? 'BLOCKED' : 'OK',
            timestamp: getCurrentTime(),
            bot_login_status: global.client.api ? 'Logged In' : 'Not Logged In / Initializing',
            uptime_seconds: Math.floor((Date.now() - global.client.timeStart) / 1000),
            blocked: isBlocked
        });
    });

    server = app.listen(PORT, '0.0.0.0', () => {
        logger.log(`Uptime Robot endpoint listening on port ${PORT}`, "SERVER");
    }).on('error', (err) => {
        logger.err(`Failed to start Express server on port ${PORT}: ${err.message}. This is critical for uptime monitoring.`, "SERVER_ERROR");
    });
}

// --- Main Program Entry Point ---
startWebServer();
onBot();

// --- Process Event Handlers for Stability and Graceful Shutdown ---
process.on('uncaughtException', (err) => {
    logger.err(`Uncaught Exception: ${err.stack || err.message}`, "CRITICAL");
    // Attempt to log the error, then exit gracefully
    if (server) {
        server.close(() => {
            logger.log('Web server closed.', 'SHUTDOWN');
            process.exit(1);
        });
    } else {
        process.exit(1);
    }
});

process.on('unhandledRejection', (reason, promise) => {
    logger.err(`Unhandled Rejection at: ${promise}, reason: ${reason}`, "CRITICAL");
    // Attempt to log the error, then exit gracefully
    if (server) {
        server.close(() => {
            logger.log('Web server closed.', 'SHUTDOWN');
            process.exit(1);
        });
    } else {
        process.exit(1);
    }
});

function gracefulShutdown() {
    logger.log('Initiating graceful shutdown...', 'SHUTDOWN');
    if (global.client.listenMqtt) {
        global.client.listenMqtt.stopListening();
        logger.log('Stopped listening to MQTT events.', 'SHUTDOWN');
    }
    if (server) {
        server.close(() => {
            logger.log('Web server closed.', 'SHUTDOWN');
            process.exit(0);
        });
    } else {
        process.exit(0);
    }
}

process.on('SIGTERM', gracefulShutdown);

process.on('SIGINT', gracefulShutdown);

// Auto-restart if process dies
process.on('exit', (code) => {
    if (code !== 0 && global.config?.autoRestart?.enabled) {
        logger.err(`Process exiting with code ${code} - attempting to restart`, "RESTART");
        setTimeout(() => {
            require('child_process').spawn(process.argv.shift(), process.argv, {
                cwd: process.cwd(),
                detached: true,
                stdio: 'inherit'
            });
        }, 1000);
    }
});
